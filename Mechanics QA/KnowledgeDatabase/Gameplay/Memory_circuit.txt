Latches and flip-flops are effectively 1-bit memory cells. They allow circuits to store data and deliver it at a later time, rather than acting only on the inputs at the time they are given. As a result of this, they can turn an impulse into a constant signal, "turning a button into a lever".
Devices using latches can be built to give different outputs each time a circuit is activated, even if the same inputs are used, and so circuits using them are referred to as "sequential logic". They allow for the design of counters, long-term clocks, and complex memory systems, which cannot be created with combinatorial logic gates alone. Latches are also used when a device needs to behave differently depending on previous inputs.
There are several basic categories of latches, distinguished by how they are controlled. For all types, the input lines are labeled according to their purpose (Set, Reset, Toggle, Data, Clock). There are also more arbitrary labels: The output is commonly labeled Q for historical reasons. Sometimes there is also an "inverse output" Q̅, which is always ON when Q is OFF and vice versa. If both Q and Q̅ are available, we say the circuit has "dual outputs". Most of the following types can be built as a "latch" that responds to the level of a signal, or as a "flip-flop" triggered by a change in the signal. A RS latch has separate control lines to set (turn on) or reset (turn off) the latch. Many also have dual outputs. The oldest form of RS latch in Minecraft is the RS-NOR latch, which forms the heart of many other latch and flip-flop designs.
 A T latch has only one input, the toggle. Whenever the toggle is triggered, the latch changes its state from OFF to ON or vice versa. There are also SRT latches, combining the inputs and abilities of the RS and T latches.
 A D latch has a data input and a clock input. When the clock is triggered, the data input is copied to the output, then held until the clock is triggered again.
 A JK latch has three inputs: A clock input, and the J and K inputs. (J and K don't stand for anything.) When the clock is triggered, the latch's output can be set, reset, toggled, or left as is, depending on the combination of J and K. While these are common in real-world electronics, in Minecraft they tend to be bulky and impractical—most players would use an SRT latch instead.
An RS latch has 2 inputs, S and R. The output is conventionally labeled Q, and there is often an optional "inverse output" Q̅. (Having both Q and Q̅ is called "dual outputs"). When a signal comes into S, Q is set on and stays on until a similar signal comes into R, upon which Q is reset to "off". Q̅ indicates the opposite of Q -- when Q is high, Q̅ is low, and vice versa. Where a Q̅ output is available, you can often save a NOT gate by using it instead of Q.
Note that the proper name for this category of latch is "SR latch". However, in real-world electronics as in Minecraft, the classic implementation of such latches starts by inverting the inputs; such a latch is the proper "RS latch", but they're so common that the term is commonly used also for what "should" be called SR latches.
Typical uses include an alarm system in which a warning light stays on after a pressure plate is activated until a reset button is pushed, or a rail T-junction being set and reset by different detector rails. RS latches are common parts of other circuits, including other sorts of latches.
Setting both inputs high simultaneously is a "forbidden" condition, generally something to avoid. In the truth table, S=1, R=1 breaks the inverse relationship between Q and Q̅. If this happens, you will get "undefined behavior"—various designs can do different things, and especially Q and Q̅ can be high or low at the same time. If the forbidden state is co-opted to toggle the output, the circuit becomes a JK latch, described in its own section. If there is instead a third input which toggles the output, the circuit becomes an "RST latch".
Any RS latch with dual outputs is functionally symmetrical: pulsing each input turns on "its" output, and turns off the other one. Thus R and S are interchangeable, if you also swap the outputs: Which input you pick as S chooses which of the outputs is Q, then the other input will be R and the other output will be Q̅. (If the original circuit only had a Q output, then swapping the inputs will turn it into Q̅.) In several designs (A, B, D, F, I) the functional symmetry is reflected by the circuit's physical symmetry, with each input energizing the torch it leads to, while turning off the other.
RS latches can be built in a number of ways Two NOR gates can be linked so that whichever is lit, the other will be off. The RS NOR latch is the "original" RS latch, and still among the smallest memory devices that can be made in vanilla Minecraft. While they can be built with just torches and redstone dust, repeaters can also be used. Many of these designs have "duplex I/O"—the same locations can be used to read or set the latch state.
RS latches can be built in a number of ways It is also possible to construct an RS NAND latch, using NAND gates instead of NOR gates. These will be larger and more complex than an RS NOR latch, but may be useful for specialized purposes. Their inputs are inverted (see below for details).
RS latches can be built in a number of ways Other RS latches can be created by fitting an "input sustaining circuit" with a reset switch, say by adding a pair of NOT gates or a piston, placed so as to interrupt the circuit when triggered. Such a construction can be nearly as compact as an RS NOR latch (and often with better I/O isolation and/or timing), but they will usually not have a natural Q̅ output.
RS latches can be built in a number of ways Other devices can also be involved. Pistons can be used to physically toggle a block's location, while hoppers or droppers can pass around an item entity. These circuits can be very fast and small, with little redstone dust.
Basic RS-NOR Latches.
Designs A and B are the most fundamental RS-NOR latches. In both cases, their inputs and outputs are "duplex"—the latch state can be read (Q) or set (S) on one side of the circuit, while on the other side, the latch can be reset (R), or the inverse output read (Q̅). If separate lines for input and output are needed, opposite ends of B can be used, or A can be elaborated into A' with separate locations for all four lines.
Isolated RS-NOR Latches.
These can be modified to provide separate, even isolated, input and output. C and D use torches and repeaters respectively to isolate the outputs, though the inputs can still be read. E expands the circuit slightly to isolate all four I/O lines.
Vertical RS-NOR Latches.
Design F provides a vertical (1-wide) option; again, the I/O is duplex, though isolated outputs can be taken at alternate locations.
Design G takes up more room than F, but may be preferable, as both the set and reset are on the same side. Also, be sure to compensate for the extra tick on (Q̅), caused by the last torch.
An RS latch can also be designed using NAND gates. In Minecraft, these are less efficient than the RS NOR latch, because a single Redstone torch acts as a NOR gate, whereas several torches are required to create a NAND gate. However, they can still be useful for specialized purposes.
Such an "RS NAND latch" is equivalent to an RS NOR, but with inverters applied to all the inputs and outputs. The RS NAND is logically equivalent to the RS NOR, as the same R and S inputs give the same Q output. However, these designs take inverse R and S (R̅, S̅) as inputs. When S̅ and R̅ are both off, Q and Q̅ are on. When S̅ is on, but R̅ is off, Q̅ will be on. When R̅ is on, but S̅ is off, Q will be on. When S̅ and R̅ are both on, it does not change Q and Q̅. They will be the same as they were before S̅ and R̅ were both turned on.
RS-NAND Latches.
This table summarizes the resources and features of the RS latches which use only redstone dust, torches, and repeaters.
An "Input-Stabilizing Circuit" responds to an input pulse by turning its input on and leaving it on. This can be built up into an RS Latch by adding a means to turn it off. These circuits usually don't offer a "natural" Q̅ output. Design J adds a pair of NOT gates, with the reset going to the second torch. (The NOT gates can also be added to the upper redstone loop.) Design K uses its piston to block the circuit where it goes up onto the solid block. Design L shows the reverse approach, breaking the circuit by withdrawing a power-carrying block.
RS-ISR Latches.
Other RS Latches.
A pair of non-sticky pistons can be used to physically push a block back and forth. This can make or break a circuit from a torch, producing an RS latch with no inverse output (M). If the block being pushed is a block of redstone, the circuit can be even smaller, with dual outputs (N). Both of these have isolated inputs and outputs. Putting two blocks between the pistons produces an SRT latch O, with an extra input to toggle the latch state. And droppers can also be pressed into service, as in design P: Small, tileable, but it does require a comparator.
An RS latch can easily be expanded into a monostable circuit, which automatically disables itself some time after being activated. To do this, split the output redstone path into 2 parts. The new path should run through some repeaters, and in to the reset input. When you turn on the latch, the redstone will run through the delay before turning off the latch. (This works not only for Q and R, but for Q̅ and S as well.) You can also use a more complex delay mechanism instead of repeaters, e.g. a water clock.
An "Enable/Disable RS latch" can be made by adding a pair of AND gates in front of the inputs, testing each of them against a third input, E. Now if E is true, the memory cell works as normal. If E is false, the memory cell will not change state. That is, E latches (or equivalently, clocks) the RS latch itself. Note that for design Q, the outputs are not isolated, and a signal to them can set the latch regardless of E. Alternatively, repeaters could be used to latch the inputs, but this costs more and saves no space.
As noted above, if it is possible to add a "toggle" input, the RS latch becomes an RST latch. If the "forbidden" state is used for the toggle, then it's a JK latch.
Enable/Disable RS Latch.
A D ("data") flip-flop or latch has two inputs: The data line D, and the "clock" input C. When triggered by C, the circuits set their output (Q) to D, then hold that output state between triggers. The latch form, a "gated D latch", is level triggered. It can be high- or low-triggered; either way, while the clock is in the trigger state, the output will change to match D. When the clock is in the other state, the latch will hold its current state until triggered again. A D flip-flop is edge triggered; it sets the output to D only when its clock input changes from "off" to "on" (positive edge) or vice versa (negative edge), according to the circuit. An edge trigger can turn a gated D latch into a D flip flop.
Building these devices with torches is fairly unwieldy, though some older designs are given below. Happily, since version 1.4 of Minecraft, repeaters have a special latching ability, which drastically simplifies the problem. Now a gated D latch can be made with two repeaters, and a D flipflop with four repeaters and a torch.
Design G uses the repeater's new latching feature, added to the game in version 1.4. It holds its state while the clock is high, and is by far the most compact of the D latch designs. Design H combines two such latches, one high and one low triggered, to create a positive edge-triggered D flip-flop. The block and redstone torch can be reversed for a negative edge-triggered design. The design is based on a real life implementation of an edge-triggered D flip-flop called a "Master-Slave" configuration.
For historical interest, here are several older designs, not dependent on latched repeaters, along with a table of their resource needs and other characteristics. A few of these designs also have the additional inputs and inverse output of an RS Latch.
This basic level-triggering gated D latch (design A) sets the output to D as long as the clock is set to OFF, and ignores changes in D as long as the clock is ON. However, on a positive clock edge, if D is low, the output will pulse high for 1 tick, before latching low.
Design B includes a rising-edge trigger and it will set the output to D only when the clock goes from OFF to ON. The torch-based edge trigger could also be replaced with one of the designs from the Pulse circuit page.
The circuits are based on an RS latch, with a front-end to set it appropriately. The RS latch can also be triggered directly: using the R and S inputs can override the clock and force a certain output state. So can sending signals into the Q and Q̅ lines, because the output is not isolated. To get isolated outputs, just add inverters and swap the labels.
D Latch A.
D Latch B.
Design C is a one block wide vertical version of A, except for using a non-inverted clock. It sets the output to D while the clock is ON (turning the torch off). This design can be repeated in parallel every other block, giving it a much smaller footprint, equal to the minimum spacing of parallel data lines. A clock signal can be distributed to all of them with a wire running perpendicularly under the data lines, allowing multiple flip-flops to share a single edge-trigger if desired. The output Q̅ is most easily accessed in the reverse direction, toward the source of input. As in design A, the un-isolated Q and Q̅ wires can do double duty as R and S inputs. Q can be inverted or repeated to isolate the latch's Set line.
D Latch C.
D Latch D.
Design E provides a more compact (but more complex) version of A, while still affording the same ceiling requirement. E' allows the latch to act on a high input.
Design F holds its state while the clock is high, and switches to D when the clock falls low. The repeater serves to synchronize the signals that switch out the loop and switch in D. It must be set to 1 to match the effect of the torch.
D Latch E.
D Latch F.
A JK flip-flop is another memory element which, like the D flip-flop, will only change its output state when triggered by a clock signal C. They can be edge-triggered (designs A, D, E) or level-triggered (C). Either way, the two inputs are called J and K. These names are arbitrary, and somewhat interchangeable: if a Q̅ output is available, swapping J and K will also swap Q and Q̅.
When the flip-flop is triggered the effect on the output Q will depend on the values of the two inputs If the input J = 1 and the input K = 0, the output Q = 1.
When the flip-flop is triggered the effect on the output Q will depend on the values of the two inputs When J = 0 and K = 1, the output Q = 0.
When the flip-flop is triggered the effect on the output Q will depend on the values of the two inputs If both J and K are 0, then the JK flip-flop maintains its previous state.
When the flip-flop is triggered the effect on the output Q will depend on the values of the two inputs If both are 1, the output will complement itself — i.e., if Q = 1 before the clock trigger, Q = 0 afterwards.
The table summarizes these states — note that Q(t) is the new state after the trigger, while Q(t-1) represents the state before the trigger.
The JK flip-flop's complement function (when J and K are 1) is only meaningful with edge-triggered JK flip-flops, as it is an instantaneous trigger condition. With level-triggered flip-flops (e.g. design C), maintaining the clock signal at 1 for too long causes a race condition on the output. Although this race condition is not fast enough to cause the torches to burn out, it makes the complement function unreliable for level-triggered flip-flops.
The JK flip-flip is a "universal flip-flop", as it can be converted to any of the other types: It's already an RS latch, with the "forbidden" input used for toggling. To make it a T flip flop, set J = K = T, and to make it a D flipflop, set K to the inverse of J, that is J = K̅ = D. In the real world, mass production makes JK latches useful and common: a single circuit to produce in bulk, that can be used as any other sort of latch. In Minecraft, however, JK latches are generally larger and more complex than the other types, and using their toggle function is awkward. It's almost always easier to build the specific latch type needed. Notably, an SRT Latch has all the same abilities, but gets the toggle function from a separate input.
Design E is a vertical JK Flip-Flop from the basis of design A.
Aside from these redstone designs, it is also possible to make a JK flip-flop by modifying a rail toggle, or with newer components such as hoppers and droppers.
JK Latch A.
JK Latch C.
JK Latch D.
JK Latch E.
T flip-flops are also known as "toggles." Whenever T changes from OFF to ON, the output will toggle its state. A useful way to use T flip-flops in Minecraft could for example be a button connected to the input. When you press the button the output toggles (a door opens or closes), and does not toggle back when the button pops out. These are also the core of all binary counters and clocks, as they function as a "period doubler", releasing one pulse for every two received.
There are many ways to build a T flipflop, ranging from torches and dust through pistons to more exotic devices. Many designs depend on a quirk in sticky-piston behavior, namely that after pushing a block, a sticky piston will let go of it if the activating pulse was 1 tick or less. This allows short pulses to toggle the position of a block, which is obviously useful here.
These are designs which seem markedly superior in various categories.
T Latch L3.
T FlipFlop L4.
T FlipFlop L5.
T FlipFlop L6.
L3 is a latch, which responds to a high level. Like most T latches, if the toggle line is held high too long, it will "oscillate", toggling repeatedly. That being said, make sure you use a stone button and not a wooden button as wooden buttons do stay active for a little bit longer which will cause this oscillation effect. L5 is a true flipflop with the same footprint (but higher), which triggers on a rising edge. Both are extremely compact, thanks to the use of latched repeaters. L4 is even smaller, but requires a piston (thus not silent), and it activates on a falling edge. L6 is a compact 1-high adaptation of D flip-flop H. The video shows L6 and a similar T FlipFlop.
Linear tilable TFF M.
Design M is a 1-wide dual-piston design, which can be tiled adjacent to each other for compact circuitry. (If they don't have to be right next to each other, dust can be used instead of the output repeater.) The hidden piston forms a simple monostable circuit that cuts off the button signal (10 ticks or so) as soon as a 1-tick signal has passed through to the second repeater. Due to the piston quirk mentioned above, this 1-tick signal lets the main piston toggle the position of its mobile block, to set or unset the latch and the output.
3×3 piston TFF N.
That linear design can also be bent into a 3×3 square, as N. (The "any" blocks can be air, and that torch can just as well be on the ground.) Tiling design N is a little tricker, but it can be done in either horizontal direction, by mirroring adjacent copies. Note that the output can be taken from whichever side of that corner is free, but you'll need repeaters to keep adjacent outputs from cross-connecting.
2 piston TFF O.
Design O uses a single block that swaps positions (between above a torch and not) when the top dust receives a signal; it is a dual piston design that uses only three torches, two dust, and three solid blocks. While not the most compact design possible at 1×4×4, it requires no slime balls and uses few resources while allowing for four areas to input and two areas to output.
T FlipFlop A.
T FlipFlop B.
T Latch D.
T FlipFlop E.
T FlipFlop J.
T FlipFlop K.
Design A demonstrates that a TFF can be made solely with redstone dust and torches, but it sprawls over 9×7×3 blocks. Design B is slightly unreliable for very long pulses; while the input is on, the piston will toggle every time the block below the piston arm is updated.
The design D (another torches-and-dust design, but vertical) does not have an incorporated edge trigger and will toggle multiple times unless the input is passed through one first. Design E adds such a trigger (and a repeater).
Designs J and K make more use of repeaters, but not as latches, and they are still quite large.
T FlipFlop L1.
T FlipFlop L2.
Design L2, (also L3, L4, and L5 above) relies on the redstone repeater locking mechanic introduced in version 1.4.2. L4 is the smallest, but requires a piston and activates on a falling edge.
T FlipFlop Z3.
T FlipFlop Z4.
T FlipFlop Z5.
"In a void", that is include required blocks supporting redstone.The number of ticks from the trigger to switching the output.How often the latch can toggle, including any recovery time. This is the period of the fastest clock that can drive it.P == normal piston, SP == sticky piston, C == comparator, H == hopper, D == dropper.rising edge (the usual), falling edge, high or low level. Level-triggered TFFs oscillate on long pulses.
Pressure-Plate Rail TFF (B).
Basic Rail TFF (A).
The Rail T flip-flop is a T flip-flop which uses rails and redstone. The general design uses a length of track that is stopped by a block at both ends. When the T flip-flop is in a stable state, the minecart is at either end of the track (depending on the state). An input pulse turns on powered rails at both ends of the track, causing the minecart to move to the other end.
Along the track, there are two separate detector elements (e.g. detector rails). These two detectors are each connected to an input of an RS NOR latch, and hence serve to translate minecart motion into a state transition. When the minecart moves, depending on its direction of motion, one detector will turn on (and off) before the other; the second detector to be hit is what determines which input of the RS NOR latch stays on last and hence what the new state of the RS NOR latch is.
Design A uses detector rails, while design B uses pressure plates. (A minecart triggers a pressure plate on the inside of a turn, including diagonals.) Note that for B, the other side of the latch isn't a true Q̅, as the passage of the cart turns on Q before actually switching the latch.
This type of T flip-flop is slower than traditional redstone-only circuits, but this may be desirable in certain situations. With T flip-flop designs that are level-triggered (as opposed to clocked or edge-triggered), a long input pulse will cause the flip-flop to continuously switch state (oscillate) while the pulse is present. In pure redstone circuits, this is only limited by the redstone circuit delays, and hence a relatively short input pulse can cause several state transitions. Pure redstone T flip-flops usually include an edge-trigger or pulse-limiting circuit to the design, since the input pulse usually can't be guaranteed to be short enough without the use of that kind of circuit.
With rail-based designs, the speed at which the output can flip is limited by the time needed for the cart to move from one end of its rail to the other, which allows for a much longer pulse to be applied to a level-triggered input without needing an edge-trigger or pulse limiter circuit. However, the delay between the input pulse and the output transition is also longer.
Grizdale's Compact TFF.
This hopper/dropper design is not only compact, but tileable in three dimensions. The only hitch (for survival mode) is that you need access to Nether Quartz for the comparator.
The A variant has a size of 1×2×3. The B variant puts the input and output inline, but changes the footprint to 2×2×2, or 4×2×2 if you want fully powered input and output. The B design can also be tiled in line, side by side, vertically (by reversing alternate rows), or all three at once.
Once built, place a single item inside any of the containers and it will work as a T Flip-flop, with the item cycling between the two droppers. The core has a 1 tick delay between input and turning off or on, but the optional repeaters would raise this to 3.
This T Flip Flop can be turned into an SRT latch by only powering the bottom dropper to set, and the top to reset. However, it won't be as tileable as the original TFF.
First known appearance: 23 March 2013 on this forum thread.
T FlipFlop Z1.
T FlipFlop Z2.
Designs Z1 and Z2 do not work as of version 1.5.2 -- in both cases, their pulse generator does not cause the piston to toggle its block as apparently intended.
