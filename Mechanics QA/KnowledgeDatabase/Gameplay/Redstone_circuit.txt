A redstone circuit is a structure that can be built to activate or control mechanisms.
Circuits can be designed to act in response to player activation, or to operate autonomously—either on a loop, or in response to non-player activity such as mob movement, item drops, plant growth, etc. The mechanisms that can be controlled by redstone circuits range from simple devices such as automatic doors and light switches, to complex devices such as elevators, automatic farms, or even in-game computers. Understanding how to build and use redstone circuits and the mechanisms they can control will greatly increase the range of things that can be accomplished in Minecraft.
The subject of redstone structures is huge — this article provides only an overview of the many different types of redstone circuits which can be built. For full details and examples of these redstone circuits, see the main articles for each topic.
Before describing the blocks used to build redstone circuits, or the types of circuits which can be built, an understanding of some basic concepts is required.
A redstone component is a block that provides some purpose to a redstone circuit. A power component provides power to all or part of a circuit — e.g., redstone torch, button, lever, redstone block, etc.
 A transmission component passes power from one part of the circuit to another — e.g., redstone dust, redstone repeater, redstone comparator.
 A mechanism component affects the environment (by moving, producing light, etc.) — e.g., piston, redstone lamp, dispenser, etc.
Redstone components and blocks may be powered or unpowered. Think of a "powered block" as a block that is electrified (but safe to touch). Some blocks will show their powered state visibly (for example, redstone dust lights up, a piston extends, etc.), but other blocks may give no visual indication of their powered state other than their effect on other redstone components.
An opaque block (e.g., stone, sandstone, dirt or grass, etc.) powered by a power component, or by a repeater or comparator, is said to be strongly-powered (a different concept from power level). A strongly-powered block can power adjacent redstone dust (including dust on top of the block or dust beneath it).
An opaque block powered only by redstone dust (and no other components) is said to be weakly-powered because a block powered only by redstone dust will not power other redstone dust (but can still power other components or devices).
No opaque block can directly power another opaque block—there must be dust or a device in between. A transparent block can't be powered by anything. "Strong" vs. "weak" power applies only to opaque blocks, not to dust or other redstone components.
A powered block (strong or weak) can affect adjacent redstone components. Different redstone components react differently to powered blocks—see their individual descriptions for details.
Power level (aka "signal strength") can vary from 0 to 15. Most power components provide power level 15, but a few provide a variable amount of power.
Redstone dust transmits power to adjacent redstone dust, but its strength decreases by 1 for each block of redstone dust traveled. Redstone dust can thus transmit power up to 15 blocks before needing to be maintained with a redstone comparator or re-strengthened with a repeater. Power level only fades with dust-to-dust transmission, not between dust and a device or block.
Power level can also be adjusted directly with a redstone comparator in comparison or subtraction mode.
When a change occurs somewhere in a redstone circuit, it can produce other changes in surrounding blocks in what is called a redstone update (not to be confused with Minecraft 1.5, known as the "Redstone Update"). Each of these changes can then produce other changes in their surrounding blocks. The update will propagate following the redstone circuit rules within loaded chunks (redstone updates will not propagate into unloaded chunks), usually very quickly.
A redstone update simply notifies other redstone components that a change has occurred nearby and gives them an opportunity to change their own state in response, but not all updates will necessarily require changes. For example, if a redstone torch activates and updates the dust below it, the dust may already be powered from something else, in which case the dust won't change state and the update propagation will stop there.
Redstone components can also be updated by any immediate neighbor block being placed, moved, or destroyed.
Solid blocks don't "know" if they're powered or not. Redstone updates simply update enough blocks around a redstone component to update other redstone components around the solid block (for example, a pressure plate updates its neighbors and the neighbors of the block it's attached to, which includes the space under that block which might be redstone dust).
In addition to redstone updates, comparators can be updated by containers (including detector rails with container minecarts on them) and certain other blocks, up to two blocks away horizontally when their state changes (for example, when their inventory changes).
The following redstone components produce redstone updates up to two blocks away by taxicab distance, including up and down Redstone Comparator.
The following redstone components produce redstone updates up to two blocks away by taxicab distance, including up and down Redstone Dust.
The following redstone components produce redstone updates up to two blocks away by taxicab distance, including up and down Redstone Repeater.
The following redstone components produce redstone updates up to two blocks away by taxicab distance, including up and down Redstone Torch.
The following redstone components produce redstone updates up to two blocks away by taxicab distance, including up and down Slanted rails, activator rails, detector rails, and powered rails (but not flat rails, etc).
The following redstone components produce redstone updates in their immediate neighbors, including above and below, and in the immediate neighbors of the block they're attached to Button.
The following redstone components produce redstone updates in their immediate neighbors, including above and below, and in the immediate neighbors of the block they're attached to Detector Rail (flat only; also produces comparator updates).
The following redstone components produce redstone updates in their immediate neighbors, including above and below, and in the immediate neighbors of the block they're attached to Lever.
The following redstone components produce redstone updates in their immediate neighbors, including above and below, and in the immediate neighbors of the block they're attached to Pressure Plate.
The following redstone components produce redstone updates in their immediate neighbors, including above and below, and in the immediate neighbors of the block they're attached to Trapped Chest (as if "attached" to the block beneath; also produces comparator updates).
The following redstone components produce redstone updates in their immediate neighbors, including above and below, and in the immediate neighbors of the block they're attached to Tripwire Hook.
The following redstone components produce redstone updates in their immediate neighbors, including above and below, and in the immediate neighbors of the block they're attached to Weighted Pressure Plate.
The following redstone components update only their immediate neighbors when they change their state, including above and below Activator Rail (flat only).
The following redstone components update only their immediate neighbors when they change their state, including above and below Daylight Sensor.
The following redstone components update only their immediate neighbors when they change their state, including above and below Tripwire (can also activate tripwire hooks in valid tripwire circuit).
The following redstone components update only their immediate neighbors when they change their state, including above and below Piston and Sticky Piston (from both the piston base and the piston head when extended).
The following redstone components update only their immediate neighbors when they change their state, including above and below Powered Rail (flat only).
The following redstone components update only their immediate neighbors when they change their state, including above and below Rail (flat only).
The following redstone components do not produce block or redstone updates when they change their state (though any block will produce a block update in its immediate neighbors if moved or destroyed) Command Block (also produces comparator updates).
The following redstone components do not produce block or redstone updates when they change their state (though any block will produce a block update in its immediate neighbors if moved or destroyed) Dispenser (also produces comparator updates).
The following redstone components do not produce block or redstone updates when they change their state (though any block will produce a block update in its immediate neighbors if moved or destroyed) Dropper (also produces comparator updates).
The following redstone components do not produce block or redstone updates when they change their state (though any block will produce a block update in its immediate neighbors if moved or destroyed) Door.
The following redstone components do not produce block or redstone updates when they change their state (though any block will produce a block update in its immediate neighbors if moved or destroyed) Fence Gate (can be moved).
The following redstone components do not produce block or redstone updates when they change their state (though any block will produce a block update in its immediate neighbors if moved or destroyed) Hopper (also produces comparator updates).
The following redstone components do not produce block or redstone updates when they change their state (though any block will produce a block update in its immediate neighbors if moved or destroyed) Note Block.
The following redstone components do not produce block or redstone updates when they change their state (though any block will produce a block update in its immediate neighbors if moved or destroyed) Redstone Lamp (can be moved).
The following redstone components do not produce block or redstone updates when they change their state (though any block will produce a block update in its immediate neighbors if moved or destroyed) Trapdoor (can be moved).
A redstone tick is the moment when Minecraft updates redstone components. Redstone updates occur 10 times per second, so a redstone tick occurs every 0.1 seconds. Redstone torches, redstone repeaters, and mechanism components require one or more ticks to change state, so it can take a number of ticks for a signal to propagate through a complicated circuit.
Redstone ticks differ from "game ticks" (20 per second) and "block ticks" (block updates that occur at each game tick). When discussing redstone circuits, a "tick" is always a redstone tick, unless otherwise specified.
Circuits with a stable output are said to produce a signal — an ON signal (also "high" or "1") if powered, or an OFF signal ("low", "0") if unpowered. When a signal changes from OFF to ON and then back again, that is described as a pulse (or ON pulse), while the opposite is described as an OFF pulse. ON pulses are far more common, and in casual discussion, "a signal" often refers to an ON pulse.
Very short pulses (1 or 2 ticks) can cause problems for some components or circuits because they have different update sequences to change states. For example, a redstone torch or a comparator will not respond to a 1-tick pulse made by repeaters.
Mechanism components (pistons, doors, redstone lamps, etc.) can be activated, which causes the mechanism component to do something (push a block, open the door, turn on, etc.).
All mechanism components are activated by an adjacent active power component, including above or below.
Exceptions: a redstone torch will not activate a mechanism component it is attached to, and a piston is not activated by a power component directly in front of it.
an adjacent powered opaque block (either strongly-powered or weakly-powered), including above or below.
a powered redstone comparator or redstone repeater facing the mechanism component.
powered redstone dust configured to point at the mechanism component (or on top of it, for mechanism components which can support redstone dust, but not beneath it), or adjacent "directionless" redstone dust; a mechanism component is not activated by adjacent powered redstone dust which is not configured to point at it.
Some mechanism components only perform an action when initially activated (command blocks execute a command, droppers and dispensers eject an item, note blocks play a sound) and won't do anything again until deactivated and then activated again, while other mechanism components change their state when activated and don't change back until the activation ends (redstone lamps stay on, doors/fence gates/trapdoors stay open, hoppers stay disabled, pistons stay extended, etc.).
Some mechanism components have additional ways of being activated dispensers, droppers, and pistons can also be activated if one of the methods above would activate a mechanism component in the block above the component, even if there is no mechanism component there (even if the block above the component is air or a transparent block). This rule is often simplified to saying that the components can be powered by blocks diagonally above or two blocks above, but other methods of such activation exist (see image to the right). This method of activation is known as quasi-connectivity because the mechanism component's activation is somewhat connected to the space above it.
Some mechanism components have additional ways of being activated doors occupy two spaces, one above the other, and anything that activates either space also activates the other.
For opaque mechanism components (command blocks, dispensers, droppers, note blocks and redstone lamps), it is important to make a distinction between a mechanism component being activated and being powered (and this is the reason why mechanism components are described as activated instead of just saying they are powered). A mechanism component is powered if it could power adjacent redstone dust, repeaters, or comparators.
 A mechanism component is activated if it is doing something (or has done something and is waiting to be activated again).
Any method of powering a mechanism component (such as a redstone torch underneath it) will also activate it, but some activation methods (such as a redstone torch next to or above a mechanism component) won't actually power the component (following the usual rules for power components).
Non-opaque mechanism components (doors, fence gates, hoppers, pistons, rails, trapdoors) can be activated (they can do things), but cannot be powered (in the sense that they can then power adjacent redstone dust, etc.).
These terms are sometimes used interchangeably to describe structures which incorporate redstone components, but a useful distinction can be made between the two A circuit performs operations on signals (generating, modifying, combining, etc.).
These terms are sometimes used interchangeably to describe structures which incorporate redstone components, but a useful distinction can be made between the two A mechanism manipulates the environment (moving blocks, opening doors, changing the light level, producing sound, etc.).
All mechanisms will necessarily incorporate redstone components or circuits, but a circuit by itself doesn't have to have an effect on the environment (except possibly incidentally, such as a redstone torch changing its light level when changing its power state, or a piston moving a block to fulfill a role within the circuit). Making this distinction allows us to talk about circuits without having to define a specific in-game purpose for them, allowing players to find their own reasons to use them.
This article, and the other articles on redstone circuits, discuss only circuits which operate on signals. For articles about mechanisms, see the list of tutorials at the end of the article.
The wiki describes circuit size (the volume of the rectangular solid it occupies) with the notation of shorter width × longer width × height, including support/floor blocks, but not including inputs/outputs.
Another method used for describing circuit size in the Minecraft community is to ignore non-redstone blocks simply used for support (for example, blocks under redstone dust or repeaters). However, this method is unable to distinguish between flat and 1-high circuits, as well as some other circuit differences.
Sometimes it is convenient to compare circuits simply by the area of their footprint (e.g., 3×4 for a circuit three block wide by four blocks long), or by a single dimension important in a particular context (e.g., length in a sequence of sub-circuits, height in a confined space, etc.).
A number of features may be considered desirable design goals.
A structure is 1-high (aka "1-tall") if its vertical dimension is one block high (meaning it cannot have any redstone components which require support blocks below them, such as redstone dust or repeaters). Also see flat.
A structure is 1-wide if at least one of its horizontal dimensions is one block wide.
A structure is flat if it generally can be laid out on the ground with no components above another (support blocks under redstone components are okay). Flat structures are often easier for beginners to understand and build, and fit nicely under floors or on top of roofs. Also see 1-high.
A structure is flush if it doesn't extend beyond a flat wall, floor, or ceiling and can still provide utility to the other side. Flush is a desirable design goal for piston-extenders, piston doors, etc. Also see hipster and seamless.
A structure is hipster if no redstone components are visible both before and after it completes its task (but it's okay if some are visible during operation). Also see flush and seamless.
A structure is instant if its output responds immediately to its input (a circuit delay of 0 ticks).
A structure is seamless if it is initially hidden behind a flat wall, floor, or ceiling and can still provide utility to the other side. Seamless is a desirable design goal for piston-extenders, piston doors, etc. Also see flush and hipster.
A structure is silent if it makes no noise (such as from piston movement, dispenser/dropper triggering when empty, etc.). Silent structures are desirable for traps, peaceful homes, and for reducing lag produced by sound.
A structure is stackable if it can be placed directly next to other copies of itself, and they all can be controlled as a single unit. Also see tileable.
A structure is tileable if it can be placed directly next to other copies of itself, and each copy can still be controlled independently. Also see stackable.
Structures might be described as "2-wide tileable" (tileable every two spaces in one dimension), or "2×4 tileable" (tileable in two directions), etc. Some structures might be described as "alternating tileable", meaning they can be placed next to each other if every other one is flipped or a slightly different design.
Other design goals may include reducing the delay a sub-circuit adds to a larger circuit, reducing the use of resource-expensive components (redstone, nether quartz, etc.), and re-arranging or redesigning a circuit to make it as small as possible.
Although the number of ways to construct circuits is endless, certain patterns of construction occur over and over again. The following sections attempt to categorize the circuits which have proven useful to the Minecraft community, while the main articles describe the specific circuits which fall into those categories.
Some of these circuits might be used by themselves for simple control of mechanisms, but frequently you will need to combine them into more complex circuits to meet the needs of a mechanism.
Some aspects of signal transmission can be helpful to understand: transmission types, vertical transmission, repeaters, and diodes.
Although horizontal signal transmission is pretty straight-forward, vertical transmission involves options and trade-offs. Redstone staircases: The simplest way to transmit signals vertically is by placing redstone dust on blocks diagonally upwards, either in a straight staircase of blocks, in a 2×2 spiral of blocks, or in another similar variation. Redstone staircases can transmit signals both upwards and downwards, but can take up a lot of space and will require repeaters every 15 blocks.
 Redstone ladders: Because glowstone, upside-down slabs and upside-down stairs can support redstone dust but don't cut redstone dust, signals can be transmitted vertically (upwards only) by alternating these blocks in a 2×1 "ladder". Redstone ladders take up less space than redstone staircases, but also require repeaters every 15 blocks.
 Torch towers and torch ladders: A redstone torch can power a block above it, or redstone dust beneath it, allowing vertical transmission both upwards or downwards (different designs are required for each). Because it takes each torch a little time to change state, a torch tower can introduce some delay into a circuit, but no repeaters are necessary.
To "repeat" a signal means to boost it back up to full strength. The easiest way to do this is with a redstone repeater. Variations include Instant Repeater: Repeats a signal without the delay introduced by a redstone repeater.
Variations include Two-Way Repeater: Repeats a signal in both directions.
A "diode" is a one-way circuit that allows a signal to travel only in one direction. It is used to protect another circuit from the chance of a signal trying to enter through the output, which could incorrectly change the circuit's state or interfere with its timing. It is also used in a compact circuit to keep one part of the circuit from interfering with another. Common choices for a diode include a redstone repeater or a height elevation to glowstone or an upside-down slab which won't transmit a signal back downwards.
Many circuits are already one-way simply because their output comes from a block which can't take input. For example, you can't push a signal back into a circuit through a redstone torch except through the block it's attached to.
It's sometimes necessary to check signals against each other and only output a signal when the inputs meet some criteria. A circuit which performs this function is known as a logic gate (a "gate" that only allows signals through if the "logic" is satisfied).
A NOT Gate (aka "inverter") is on if its input is off.
An OR Gate is on if any of its inputs are on.
A NOR Gate is on only if none of its inputs are on.
An AND Gate is on only if all of its inputs are on.
A NAND Gate is on if any of its inputs are off.
An XOR Gate is on if its inputs are different.
An XNOR Gate is on if its inputs are equal.
An IMPLIES Gate is on unless the first input is on and the second input is off.
Some circuits require specific pulses, other circuits use pulse duration as a way to convey information. Pulse circuits manage these requirements.
A circuit which is stable in one output state and unstable in the other is known as a monostable circuit. Many pulse circuits are monostable because their OFF state is stable, but their ON state will quickly (or eventually) revert to OFF.
A pulse generator produces a pulse of a specific duration.
A pulse limiter (aka pulse shortener) reduces the duration of pulses which are too long.
A pulse extender (aka pulse sustainer, pulse lengthener) increases the duration of pulses which are too short.
A pulse multiplier outputs multiple pulses for every input pulse (it multiplies the number of pulses).
A pulse divider (aka pulse counter) only outputs a signal after a certain number of pulses have been detected through the input (the number of pulses is indicative of the number of loops).
An edge detector reacts to either a signal changing from OFF to ON (a "rising edge" detector) or from ON to OFF (a "falling edge" detector), or both (a "dual edge" detector).
A pulse length detector reacts only to pulses in a certain range of durations (often only to pulses of one specific duration).
A clock circuit is a pulse generator that produces a loop of specific pulses repeatedly. Some are designed to run forever, while others can be stopped and started.
A simple clock with only two states of equal duration is named for the duration of its ON state (e.g., for example, a clock which alternates between a 5-tick ON state and a 5-tick OFF state is called a 5-clock) while others are usually named for their period (the time it takes for the clock to return to its original state; for example, a "1-minute clock" might produce a 1-tick pulse every 60 seconds).
A repeater clock consists of a loop of repeaters (usually either redstone repeaters or redstone torches) with occasional dust or blocks to draw off the appropriate pulses.
A hopper clock produces timed pulses by moving items around between hoppers and drawing signals off with redstone comparators.
A piston clock produces a loop of pulses by passing a block back and forth (or around, with many pistons) and drawing off a pulse when the block is in a certain location.
Clocks can also be built using daylight sensors, minecarts, boats, water flow, item despawn, etc.
Unlike a logic circuit whose state always reflects its current inputs, a memory circuit's output depends not on the current state of its inputs, but on the history of its inputs. This allows a memory circuit to "remember" what state it should be in, until told to remember something else. There are four basic types of memory circuits. (A few circuits combine two different types).
An RS latch has two inputs, one to set the output on and another to reset the output back to off. An RS latch built from NOR gates is known as an "RS NOR Latch", which is the oldest and most common memory circuit in Minecraft.
A T flip-flop is used to toggle a signal (like a lever). It has one input which toggles the output between on and off.
A D flip-flop has a "data" input and a "clock" input. When the clock input turns on, it sets the output to equal its data input.
A JK latch has two inputs, one to set the output on and another to reset the output back to off (like an RS latch), but when both turn on simultaneously it toggles the output between on and off (like a T flip-flop).
Unlike T Flip-Flops and RS Latches which can only hold two states (ON or OFF), a counter can be designed to hold a greater number of states.
Many other memory circuits are possible.
These circuits aren't generally needed for your typical project, but might find use in complex projects, proofs of concept, and thought experiments. Some examples.
A multiplexer is an advanced form of logic gate which chooses which of two inputs to let through as output based on an additional input (for example, if input A is ON then output input B, otherwise output input C). The reverse of this is a relay, which copies a data input to one of two outputs, depending on whether the additional input is ON or OFF.
A randomizer produces output signals unpredictably. Randomizers can be designed to produce a pulse at random intervals, or to randomize which of multiple outputs are turned ON (such as random number generators, or RNGs). Some randomizers use the random nature of Minecraft (such as cactus growth or dispenser slot selection), while others produce pseudo-randomness algorithmically.
Multi-bit circuits treat their input lines as a single multi-bit value (something other than zero and one) and perform an operation on them all at once. With such circuits, possibly combined with arrays of memory circuits, it's possible to build calculators, digital clocks, and even basic computers inside Minecraft.
A block update detector (BUD, or BUD Switch) is a circuit which "reacts" to a block changing its state (for example, stone being mined, water changing to ice, a pumpkin growing next to a pumpkin stem, etc.). BUDs react by producing a pulse, while T-BUDs (Toggleable BUDs) react by toggling their output state. These are generally based on subtle quirks or glitches in device behavior; current circuits most often depend on pistons.
Many other complex circuits are possible.
The first step in building a redstone circuit is to decide what it will do. How and where will it be controlled? Will the circuit be controlled by the player, by mob movement, or something else?
 What mechanism components will it control?
 How will the signal be transmitted from the controls to the mechanisms? Will signals need to be combined from multiple sources?
It can be helpful to choose a specific set of blocks you use to construct circuits. Then, when you run into these blocks when digging out new rooms in your base, you know you're about to damage a previously-built circuit. Common choices include stone brick, snow block, and wool. (Using different colors of wool is also a great way to keep track of different circuits).
Be careful when building circuits near water or lava. Many redstone components will "pop off" (turn into items) when washed over by liquids, and lava will destroy any items it contacts.
Be careful when building circuits to activate TNT (traps, cannons, etc.). Circuits in mid-construction can sometimes briefly power up unexpectedly, which might activate TNT. For example, if you place a redstone torch on a powered block, it won't "figure out" that it should be turned off until the next tick, and can briefly power another part of the circuit until then. Placing your TNT after the rest of the circuit is complete will help to avoid such problems and the destruction of the device itself. This also applies to any other features of the circuit which may be accidentally activated with such actions (e.g., activating a Dispenser before the circuit is ready).
When your circuit isn't working the way you think it should, take a look at it and try to find the problem. Are you trying to draw power from a weakly-powered block? Maybe you need a redstone repeater to strongly-power the block, or to pull power out of the block.
 Are you trying to transmit power through a non-opaque block? Replace it with an opaque block, or go around it.
 Did you create a short-circuit and a redstone torch that should be powered is now burned out? Fix the short-circuit and update the torch to get things going again.
 Are parts of your circuit activating when they shouldn't be? Maybe you've accidentally "crossed wires" allowing a signal from one part of the circuit to activate another part of the circuit, or a repeater's output is being allowed to cycle into its input.
 Did the behavior you were using get removed?
 Are pistons, dispensers, or droppers being indirectly powered?
Once your circuit is working, consider if it can be improved (without breaking it). Can you make the circuit faster? Reducing the number of components a signal has to travel through can speed up the circuit.
 Can you make the circuit smaller? Can you use fewer blocks?
 Can you shorten the redstone dust lines?
 Can you compact logic gates in your circuit?
 Did you use some unnecessary components?
 Can you make the circuit more robust? Will the circuit still work when activated by a very short pulse?
 Will the circuit still work when activated and deactivated rapidly in succession?
 Did an update create the opportunity for a better circuit? (e.g., comparators, locking repeaters, etc).
 Can you make the circuit quieter?
 Can you reduce any lag? Builds with many redstone components changing state frequently can cause light, sound, particle, or update lag. Redstone torches and redstone lamps change their light level when they change state. Light changes can cause block light updates in hundreds of block tiles around each component. Concealing the component in opaque blocks or placing permanent block light sources (torches, glowstone, etc.) nearby can reduce lag from block light updates.
 A number of redstone components produce sound when activated or deactivated (pistons, dispensers and droppers, doors, trapdoors, and fence gates, and note blocks). Too many sounds at once can overload Minecraft's sound engine and produce lag.
 A number of redstone components produce particles (redstone torches, redstone dust, but especially fireworks fired from dispensers). Too many particles may overload Minecraft's particle rendering and then some particles may fail to render until old particles have disappeared.
 Every time a block is moved by a piston it can produce block updates in its neighbors so moving too many blocks at once can produce lag.
 Hoppers and hopper minecarts especially may be trying to do multiple things at once (accept items pushed into them, push items into other containers, check for item entities above them). Powering unneeded hoppers to disable them or placing solid blocks above them to disable their item entity checks can help to reduce lag.
